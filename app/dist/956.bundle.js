"use strict";(self.webpackChunkstellar_odyssey=self.webpackChunkstellar_odyssey||[]).push([[956],{956:function(C,M,x){x.r(M);var _=x(96),p=x(108),g=x(465),P=x(479),l=x(667),a=x.n(l);const{Graphics:d}=g,{app:m}=_.default.PIXI;function w(s,e){const i=new d;return i.beginFill(16777215),i.drawCircle(0,0,45),i.endFill(),i.x=s,i.y=e,new p.E(i,"Circle")}function t(){const i=m.screen.width/2-300,n=m.screen.width/2+600/2,c=m.screen.height/2-400/2,r=m.screen.height/2+400/2,h=Math.random()*(n-i)+i,o=Math.random()*(r-c)+c;return w(h,o)}P.X.addEvent("Mass Spawn","interval",(0,l.E)(1e3).div(_.default.data.quarks.regenRate),()=>{_.default.data.quarks.maxParticles.gt(_.default.static.massParticles.length)&&_.default.static.massParticles.push(t())})},108:function(C,M,x){x.d(M,{E:function(){return P}});var p=function(){class l{constructor(t){this.article=t}update(){}AABBs(t){const s=this.AABB;return!(t[2]<s[0]||s[2]<t[0]||t[3]<s[1]||s[3]<t[1])}collidesPoint(t){const s=this.vertices,e=s.length;let i=!1;for(let n=0,c=e-2;n<e;n+=2)s[n+1]>t.y!=s[c+1]>t.y&&t.x<(s[c]-s[n])*(t.y-s[n+1])/(s[c+1]-s[n+1])+s[n]&&(i=!i),c=n;return i}collidesCircle(){}collidesRectangle(){}collidesPolygon(t,s){const e=this.vertices,i=s?t:t.vertices,n=[e,i];let c,r,h,o,u;for(let B=0;B<n.length;B++){const y=n[B];for(let v=0;v<y.length;v+=2){const E=(v+2)%y.length,A={x:y[E+1]-y[v+1],y:y[v]-y[E]};c=r=null;for(let f=0;f<e.length;f+=2)h=A.x*e[f]+A.y*e[f+1],(c===null||h<c)&&(c=h),(r===null||h>r)&&(r=h);o=u=null;for(let f=0;f<i.length;f+=2)h=A.x*i[f]+A.y*i[f+1],(o===null||h<o)&&(o=h),(u===null||h>u)&&(u=h);if(r<o||u<c)return!1}}return!0}collidesLine(t,s){const e=this.vertices,i=e.length;if(this.collidesPoint(t))return!0;for(let n=0;n<i;n+=2){const c=(n+2)%i;if(l.lineLine(t,s,{x:e[n],y:e[n+1]},{x:e[c],y:e[c+1]}))return!0}return!1}collides(t){return this["collides"+t.SHAPE](t)}static lineLine(t,s,e,i){const n=t.x,c=t.y,r=s.x,h=s.y,o=e.x,u=e.y,B=i.x,y=i.y,v=r-n,E=h-c,A=B-o,f=y-u,R=(-E*(n-o)+v*(c-u))/(-A*E+v*f),D=(A*(c-u)-f*(n-o))/(-A*E+v*f);return R>=0&&R<=1&&D>=0&&D<=1}}class a extends l{constructor(t,s){super(t),this.SHAPE="Rectangle",s=s||{},this._vertices=[],this.AABB=[0,0,0,0],this.set(s)}set(t){this.center=t.center||this.article,this.rotation=t.rotation?t.rotation:t.center?t.center:this.article,typeof t.square!="undefined"?this._width=this._height=t.square:(this._width=t.width||this.article.width,this._height=t.height||this.article.height),this.noRotate=t.noRotate,this.hw=this._width/2,this.hh=this._height/2,this.update()}get width(){return this._width}set width(t){this._width=t,this.hw=t/2}get height(){return this._height}set height(t){this._height=t,this.hh=t/2}update(){const t=this.AABB,s=this.center;if(this.noRotate){const e=this.hw,i=this.hh;t[0]=s.x-e,t[1]=s.y-i,t[2]=s.x+e,t[3]=s.y+i}else{const e=Math.abs(Math.sin(this.rotation.rotation)/2),i=Math.abs(Math.cos(this.rotation.rotation)/2),n=this._width,c=this._height,r=c*e+n*i,h=c*i+n*e;t[0]=s.x-r,t[1]=s.y-h,t[2]=s.x+r,t[3]=s.y+h}this.verticesDirty=!0}updateVertices(){const t=this._vertices,s=this.center,e=this.hw,i=this.hh;if(this.noRotate){const n=this.AABB;t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[1],t[4]=n[2],t[5]=n[3],t[6]=n[0],t[7]=n[3]}else{const n=this.rotation.rotation,c=Math.sin(n),r=Math.cos(n);t[0]=s.x-e*r+i*c,t[1]=s.y-e*c-i*r,t[2]=s.x+e*r+i*c,t[3]=s.y+e*c-i*r,t[4]=s.x+e*r-i*c,t[5]=s.y+e*c+i*r,t[6]=s.x-e*r-i*c,t[7]=s.y-e*c+i*r}this.verticesDirty=!1}get vertices(){return this.verticesDirty&&this.updateVertices(),this._vertices}collidesRectangle(t){return this.noRotate&&t.noRotate?this.AABBs(t.AABB):this.collidesPolygon(t)}collidesCircle(t){return t.collidesRectangle(this)}static fromRectangle(t,s,e,i){const n={x:t+e/2,y:s+i/2};return new a(n,{width:e,height:i,noRotate:!0})}}class d extends l{constructor(t,s,e){super(t),this.SHAPE="Polygon",e=e||{},this.points=s,this.vertices=[],this.AABB=[],this.set(e)}set(t){t.point&&(this.points=t.points),this.center=t.center||this.article,this.rotation=t.rotation?t.rotation:t.center?t.center:this.article,this.update()}update(){const t=this.rotation.rotation,s=Math.sin(t),e=Math.cos(t);let i=1/0,n=0,c=1/0,r=0;const h=this.points,o=h.length,u=this.vertices,B=this.center;for(let y=0;y<o;y+=2){const v=h[y],E=h[y+1],A=u[y]=B.x+v*e-E*s,f=u[y+1]=B.y+v*s+E*e;i=A<i?A:i,n=A>n?A:n,c=f<c?f:c,r=f>r?f:r}this.AABB[0]=i,this.AABB[1]=c,this.AABB[2]=n,this.AABB[3]=r,this.width=n-i,this.height=r-c,this.hw=(n-i)/2,this.hh=(r-c)/2}collidesRectangle(t){return this.collidesPolygon(t)}collidesCircle(t){return t.collidesPolygon(this)}}class m extends l{constructor(t,s){super(t),this.SHAPE="Circle",this.AABB=[],s=s||{},this.set(s)}set(t){this.radius=t.radius||this.article.width/2,this.radiusSquared=this.radius*this.radius,this.center=t.positionObject?t.positionObject:this.article,this.update()}update(){const t=this.AABB,s=this.radius,e=this.center;t[0]=e.x-s,t[1]=e.y-s,t[2]=e.x+s,t[3]=e.y+s}collidesCircle(t){const s=this.center,e=t.center,i=e.x-s.x,n=e.y-s.y,c=t.radius+this.radius;return i*i+n*n<=c*c}collidesPoint(t){const s=t.x-this.center.x,e=t.y-this.center.y;return s*s+e*e<=this.radiusSquared}collidesLine(t,s){function e(y,v){return y[0]*v[0]+y[1]*v[1]}const i=this.center,n=[i.x-t.x,i.y-t.y],c=[s.x-t.x,s.y-t.y],r=e(c,c);let o=e(n,c)/r;o=o<0?0:o,o=o>1?1:o;const u=[c[0]*o+t.x-i.x,c[1]*o+t.y-i.y];return e(u,u)<=this.radiusSquared}collidesRectangle(t){if(t.noRotate){const s=t.AABB,e=(s[2]-s[0])/2,i=(s[3]-s[1])/2,n=this.center,c=this.radius,r=Math.abs(n.x-s[0]),h=Math.abs(n.y-s[1]);if(r>e+c||h>i+c)return!1;if(r<=e||h<=i)return!0;const o=r-e,u=h-i;return o*o+u*u<=this.radiusSquared}else{const s=this.center;if(t.collidesPoint(s))return!0;const e=t.vertices;return this.collidesLine({x:e[0],y:e[1]},{x:e[2],y:e[3]})||this.collidesLine({x:e[2],y:e[3]},{x:e[4],y:e[5]})||this.collidesLine({x:e[4],y:e[5]},{x:e[6],y:e[7]})||this.collidesLine({x:e[6],y:e[7]},{x:e[0],y:e[1]})}}collidesPolygon(t){const s=this.center;if(t.collidesPoint(s))return!0;const e=t.vertices,i=e.length;for(let n=0;n<i-2;n+=2)if(this.collidesLine({x:e[n],y:e[n+1]},{x:e[n+2],y:e[n+3]}))return!0;return this.collidesLine({x:e[0],y:e[1]},{x:e[i-2],y:e[i-1]})}}return{Shape:l,Rectangle:a,Polygon:d,Circle:m}}(),g=x(96);class P{constructor(a,d="Rectangle"){this.sprite=g.default.PIXI.app.stage.addChild(a),this.x=this.sprite.x,this.y=this.sprite.y,this.collisionShape=d,this.intersects=new p[this.collisionShape](this.sprite),g.default.PIXI.app.ticker.add(this.tickerFn,this)}tickerFn(){this.sprite.x=this.x-g.default.camera.x,this.sprite.y=this.y-g.default.camera.y}collides(a){return this.intersects[`collides${a.collisionShape}`](a.intersects)}remove(a){if(this.x=this.y=1/0,this.sprite.parent.removeChild(this.sprite),Array.isArray(a)){const d=a.indexOf(this);d!==-1&&a.splice(d,1)}else typeof a=="object"&&delete this}}},479:function(C,M,x){x.d(M,{X:function(){return P}});var _=x(667),p=x.n(_),g=x(96);const P={events:[],addEvent:function(l,a,d,m){this.events.push((()=>{switch(a){case"interval":return{name:l,type:a,delay:(0,_.E)(d),callbackFn:m,timeCreated:(0,_.E)(Date.now()),intervalLast:(0,_.E)(Date.now())};case"timeout":default:return{name:l,type:a,delay:(0,_.E)(d),callbackFn:m,timeCreated:(0,_.E)(Date.now())}}})())}};g.default.PIXI.app.ticker.add(function(){const l=(0,_.E)(Date.now());for(let a=0;a<P.events.length;a++){const d=P.events[a];d.type==="interval"?l.sub(d.intervalLast).gte(d.delay)&&(d.callbackFn(),d.intervalLast=l):d.type==="timeout"&&l.sub(d.timeCreated).gte(d.delay)&&(d.callbackFn(),P.events.splice(a,1),a--)}}),g.default.PIXI.app.ticker.add(function(l){g.default.data.playtime.timewarp=(0,_.E)(),g.default.static.playtime.tActive.gain(l),g.default.static.playtime.tPassive.gain(l),g.default.static.playtime.active.gain(l),g.default.static.playtime.passive.gain(l),g.default.static.playtime.points.gain(l)})}}]);
