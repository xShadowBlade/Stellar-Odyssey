(self.webpackChunkstellar_odyssey=self.webpackChunkstellar_odyssey||[]).push([[611,553],{617:function(t,i,s){"use strict";s.r(i),s(538);var e=function(){class t{constructor(t){this.article=t}update(){}AABBs(t){const i=this.AABB;return!(t[2]<i[0]||i[2]<t[0]||t[3]<i[1]||i[3]<t[1])}collidesPoint(t){const i=this.vertices,s=i.length;let e=!1;for(let h=0,r=s-2;h<s;h+=2)i[h+1]>t.y!=i[r+1]>t.y&&t.x<(i[r]-i[h])*(t.y-i[h+1])/(i[r+1]-i[h+1])+i[h]&&(e=!e),r=h;return e}collidesCircle(){}collidesRectangle(){}collidesPolygon(t,i){const s=this.vertices,e=i?t:t.vertices,h=[s,e];let r,n,o,c,l;for(let t=0;t<h.length;t++){const i=h[t];for(let t=0;t<i.length;t+=2){const h=(t+2)%i.length,a={x:i[h+1]-i[t+1],y:i[t]-i[h]};r=n=null;for(let t=0;t<s.length;t+=2)o=a.x*s[t]+a.y*s[t+1],(null===r||o<r)&&(r=o),(null===n||o>n)&&(n=o);c=l=null;for(let t=0;t<e.length;t+=2)o=a.x*e[t]+a.y*e[t+1],(null===c||o<c)&&(c=o),(null===l||o>l)&&(l=o);if(n<c||l<r)return!1}}return!0}collidesLine(i,s){const e=this.vertices,h=e.length;if(this.collidesPoint(i))return!0;for(let r=0;r<h;r+=2){const n=(r+2)%h;if(t.lineLine(i,s,{x:e[r],y:e[r+1]},{x:e[n],y:e[n+1]}))return!0}return!1}collides(t){return this["collides"+t.SHAPE](t)}static lineLine(t,i,s,e){const h=t.x,r=t.y,n=i.x,o=i.y,c=s.x,l=s.y,a=n-h,u=o-r,d=e.x-c,y=e.y-l,x=(-u*(h-c)+a*(r-l))/(-d*u+a*y),p=(d*(r-l)-y*(h-c))/(-d*u+a*y);return x>=0&&x<=1&&p>=0&&p<=1}}class i extends t{constructor(t,i){super(t),this.SHAPE="Rectangle",i=i||{},this._vertices=[],this.AABB=[0,0,0,0],this.set(i)}set(t){this.center=t.center||this.article,this.rotation=t.rotation?t.rotation:t.center?t.center:this.article,void 0!==t.square?this._width=this._height=t.square:(this._width=t.width||this.article.width,this._height=t.height||this.article.height),this.noRotate=t.noRotate,this.hw=this._width/2,this.hh=this._height/2,this.update()}get width(){return this._width}set width(t){this._width=t,this.hw=t/2}get height(){return this._height}set height(t){this._height=t,this.hh=t/2}update(){const t=this.AABB,i=this.center;if(this.noRotate){const s=this.hw,e=this.hh;t[0]=i.x-s,t[1]=i.y-e,t[2]=i.x+s,t[3]=i.y+e}else{const s=Math.abs(Math.sin(this.rotation.rotation)/2),e=Math.abs(Math.cos(this.rotation.rotation)/2),h=this._width,r=this._height,n=r*s+h*e,o=r*e+h*s;t[0]=i.x-n,t[1]=i.y-o,t[2]=i.x+n,t[3]=i.y+o}this.verticesDirty=!0}updateVertices(){const t=this._vertices,i=this.center,s=this.hw,e=this.hh;if(this.noRotate){const i=this.AABB;t[0]=i[0],t[1]=i[1],t[2]=i[2],t[3]=i[1],t[4]=i[2],t[5]=i[3],t[6]=i[0],t[7]=i[3]}else{const h=this.rotation.rotation,r=Math.sin(h),n=Math.cos(h);t[0]=i.x-s*n+e*r,t[1]=i.y-s*r-e*n,t[2]=i.x+s*n+e*r,t[3]=i.y+s*r-e*n,t[4]=i.x+s*n-e*r,t[5]=i.y+s*r+e*n,t[6]=i.x-s*n-e*r,t[7]=i.y-s*r+e*n}this.verticesDirty=!1}get vertices(){return this.verticesDirty&&this.updateVertices(),this._vertices}collidesRectangle(t){return this.noRotate&&t.noRotate?this.AABBs(t.AABB):this.collidesPolygon(t)}collidesCircle(t){return t.collidesRectangle(this)}static fromRectangle(t,s,e,h){return new i({x:t+e/2,y:s+h/2},{width:e,height:h,noRotate:!0})}}return{Shape:t,Rectangle:i,Polygon:class extends t{constructor(t,i,s){super(t),this.SHAPE="Polygon",s=s||{},this.points=i,this.vertices=[],this.AABB=[],this.set(s)}set(t){t.point&&(this.points=t.points),this.center=t.center||this.article,this.rotation=t.rotation?t.rotation:t.center?t.center:this.article,this.update()}update(){const t=this.rotation.rotation,i=Math.sin(t),s=Math.cos(t);let e=1/0,h=0,r=1/0,n=0;const o=this.points,c=o.length,l=this.vertices,a=this.center;for(let t=0;t<c;t+=2){const c=o[t],u=o[t+1],d=l[t]=a.x+c*s-u*i,y=l[t+1]=a.y+c*i+u*s;e=d<e?d:e,h=d>h?d:h,r=y<r?y:r,n=y>n?y:n}this.AABB[0]=e,this.AABB[1]=r,this.AABB[2]=h,this.AABB[3]=n,this.width=h-e,this.height=n-r,this.hw=(h-e)/2,this.hh=(n-r)/2}collidesRectangle(t){return this.collidesPolygon(t)}collidesCircle(t){return t.collidesPolygon(this)}},Circle:class extends t{constructor(t,i){super(t),this.SHAPE="Circle",this.AABB=[],i=i||{},this.set(i)}set(t){this.radius=t.radius||this.article.width/2,this.radiusSquared=this.radius*this.radius,this.center=t.positionObject?t.positionObject:this.article,this.update()}update(){const t=this.AABB,i=this.radius,s=this.center;t[0]=s.x-i,t[1]=s.y-i,t[2]=s.x+i,t[3]=s.y+i}collidesCircle(t){const i=this.center,s=t.center,e=s.x-i.x,h=s.y-i.y,r=t.radius+this.radius;return e*e+h*h<=r*r}collidesPoint(t){const i=t.x-this.center.x,s=t.y-this.center.y;return i*i+s*s<=this.radiusSquared}collidesLine(t,i){function s(t,i){return t[0]*i[0]+t[1]*i[1]}const e=this.center,h=[e.x-t.x,e.y-t.y],r=[i.x-t.x,i.y-t.y],n=s(r,r);let o=s(h,r)/n;o=o<0?0:o,o=o>1?1:o;const c=[r[0]*o+t.x-e.x,r[1]*o+t.y-e.y];return s(c,c)<=this.radiusSquared}collidesRectangle(t){if(t.noRotate){const i=t.AABB,s=(i[2]-i[0])/2,e=(i[3]-i[1])/2,h=this.center,r=this.radius,n=Math.abs(h.x-i[0]),o=Math.abs(h.y-i[1]);if(n>s+r||o>e+r)return!1;if(n<=s||o<=e)return!0;const c=n-s,l=o-e;return c*c+l*l<=this.radiusSquared}{const i=this.center;if(t.collidesPoint(i))return!0;const s=t.vertices;return this.collidesLine({x:s[0],y:s[1]},{x:s[2],y:s[3]})||this.collidesLine({x:s[2],y:s[3]},{x:s[4],y:s[5]})||this.collidesLine({x:s[4],y:s[5]},{x:s[6],y:s[7]})||this.collidesLine({x:s[6],y:s[7]},{x:s[0],y:s[1]})}}collidesPolygon(t){const i=this.center;if(t.collidesPoint(i))return!0;const s=t.vertices,e=s.length;for(let t=0;t<e-2;t+=2)if(this.collidesLine({x:s[t],y:s[t+1]},{x:s[t+2],y:s[t+3]}))return!0;return this.collidesLine({x:s[0],y:s[1]},{x:s[e-2],y:s[e-1]})}}}}(),h=s(553);h.default.classes.sprite=class{constructor(t,i="Rectangle"){this.sprite=h.default.PIXI.app.stage.addChild(t),this.x=this.sprite.x,this.y=this.sprite.y,this.collisionShape=i,this.intersects=new e[this.collisionShape](this.sprite),h.default.PIXI.app.ticker.add(this.tickerFn,this)}tickerFn(){this.sprite.x=this.x-h.default.camera.x,this.sprite.y=this.y-h.default.camera.y}collides(t){return this.intersects[`collides${t.collisionShape}`](t.intersects)}remove(t){if(this.x=this.y=1/0,this.sprite.parent.removeChild(this.sprite),"array"==typeof t){const i=t.indexOf(this);-1!==i&&t.splice(i,1)}}}},553:function(t,i,s){"use strict";s.r(i);const e={version:{saveAPI:1,phase:"alpha"},classes:{},data:{},functions:{start:{},startF:()=>Object.values(e.functions.start).forEach((t=>t())),loop:{},loopF:t=>Object.values(e.functions.loop).forEach((i=>i(t)))},static:{},settings:{framerate:30,c2:!1},features:{}};console.log(e),i.default=e},654:function(){}}]);